<!DOCTYPE html>
<html lang="tr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ProTrade AI - Optimizer & Backtester</title>
    <script src="https://unpkg.com/lightweight-charts@4.1.1/dist/lightweight-charts.standalone.production.js"></script>
    <style>
        :root {
            --bg-dark: #131722;
            --bg-panel: #1e222d;
            --border: #2a2e39;
            --text: #d1d4dc;
            --accent: #2962ff;
            --green: #089981;
            --red: #f23645;
        }
        body { margin: 0; background: var(--bg-dark); color: var(--text); font-family: sans-serif; display: flex; height: 100vh; overflow: hidden; }
        
        /* Layout */
        aside { width: 300px; background: var(--bg-panel); border-right: 1px solid var(--border); display: flex; flex-direction: column; overflow-y: auto; }
        main { flex: 1; display: flex; flex-direction: column; position: relative; }
        
        /* Sidebar Components */
        .sidebar-header { padding: 15px; border-bottom: 1px solid var(--border); font-weight: bold; font-size: 1.1rem; color: var(--accent); }
        .control-group { padding: 15px; border-bottom: 1px solid var(--border); }
        .control-group h3 { margin: 0 0 10px 0; font-size: 0.85rem; color: #787b86; text-transform: uppercase; }
        
        label { display: block; font-size: 0.8rem; margin-bottom: 5px; }
        select, input { width: 100%; background: #2a2e39; border: 1px solid #363a45; color: white; padding: 6px; border-radius: 4px; margin-bottom: 10px; }
        
        button { width: 100%; padding: 10px; border: none; border-radius: 4px; cursor: pointer; font-weight: bold; transition: 0.2s; margin-top: 5px; }
        .btn-run { background: var(--accent); color: white; }
        .btn-opt { background: #673ab7; color: white; margin-top: 10px; }
        .btn-opt:hover { background: #5e35b1; }

        /* Chart & Stats */
        #chart { flex: 1; width: 100%; }
        .stats-panel { height: 60px; background: var(--bg-panel); border-top: 1px solid var(--border); display: flex; align-items: center; justify-content: space-around; }
        .stat-box { text-align: center; }
        .stat-val { font-size: 1.1rem; font-weight: bold; }
        .profit { color: var(--green); }
        .loss { color: var(--red); }

        /* Loading Overlay */
        #loading { position: absolute; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.8); z-index: 100; display: flex; align-items: center; justify-content: center; flex-direction: column; display: none; }
        .spinner { width: 40px; height: 40px; border: 4px solid #f3f3f3; border-top: 4px solid var(--accent); border-radius: 50%; animation: spin 1s linear infinite; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

        /* Param Inputs grid */
        .param-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 5px; }
    </style>
</head>
<body>

<aside>
    <div class="sidebar-header">ProTrade AI</div>
    
    <div class="control-group">
        <h3>Varlık Seçimi</h3>
        <label>Piyasa</label>
        <select id="market">
            <option value="CRYPTO">Kripto (Canlı)</option>
            <option value="BIST">BIST 30 (Simülasyon)</option>
            <option value="US">ABD Borsası (Simülasyon)</option>
            <option value="COMMODITY">Emtia (Simülasyon)</option>
        </select>
        <label>Sembol</label>
        <select id="symbol"></select>
        <label>Zaman Aralığı</label>
        <select id="interval">
            <option value="15m">15 Dakika</option>
            <option value="1h">1 Saat</option>
            <option value="4h" selected>4 Saat</option>
            <option value="1d">1 Gün</option>
        </select>
    </div>

    <div class="control-group">
        <h3>Strateji & Parametreler</h3>
        <label>Aktif Strateji</label>
        <select id="strategy">
            <option value="supertrend">SuperTrend</option>
            <option value="rsi">RSI Strategy</option>
            <option value="macd">MACD Cross</option>
            <option value="ema">EMA Cross</option>
            <option value="bollinger">Bollinger Bands</option>
        </select>

        <!-- Dynamic Params Area -->
        <div id="params-container"></div>
    </div>

    <div class="control-group">
        <h3>Backtest Ayarları</h3>
        <label>Başlangıç Bakiyesi ($)</label>
        <input type="number" id="balance" value="1000">
        
        <button class="btn-run" onclick="App.start()">Çalıştır</button>
        <button class="btn-opt" onclick="Optimizer.run()">✨ Otomatik Optimize Et</button>
        <div id="opt-status" style="font-size: 0.75rem; color: #aaa; margin-top: 5px; text-align: center;"></div>
    </div>
</aside>

<main>
    <div id="loading">
        <div class="spinner"></div>
        <div style="margin-top: 10px;" id="loading-text">Veriler İşleniyor...</div>
    </div>
    <div id="chart"></div>
    <div class="stats-panel">
        <div class="stat-box">
            <div style="font-size:0.7rem; color:#888">Son Bakiye</div>
            <div class="stat-val" id="res-balance">---</div>
        </div>
        <div class="stat-box">
            <div style="font-size:0.7rem; color:#888">Net Kâr</div>
            <div class="stat-val" id="res-pnl">---</div>
        </div>
        <div class="stat-box">
            <div style="font-size:0.7rem; color:#888">Win Rate</div>
            <div class="stat-val" id="res-win">---</div>
        </div>
        <div class="stat-box">
            <div style="font-size:0.7rem; color:#888">Toplam İşlem</div>
            <div class="stat-val" id="res-trades">---</div>
        </div>
    </div>
</main>

<script>
/**
 * DATA DEFINITIONS
 */
const ASSETS = {
    CRYPTO: ['BTCUSDT', 'ETHUSDT', 'BNBUSDT', 'SOLUSDT', 'XRPUSDT', 'ADAUSDT', 'AVAXUSDT', 'DOGEUSDT', 'DOTUSDT', 'TRXUSDT', 'MATICUSDT', 'LTCUSDT', 'SHIBUSDT', 'LINKUSDT', 'ATOMUSDT', 'UNIUSDT', 'XLMUSDT', 'ETCUSDT', 'FILUSDT', 'APTUSDT', 'NEARUSDT', 'QNTUSDT', 'ALGOUSDT', 'ICPUSDT', 'LDOUSDT', 'GRTUSDT', 'EOSUSDT', 'SANDUSDT', 'MANAUSDT', 'AAVEUSDT'],
    BIST: ['THYAO', 'ASELS', 'GARAN', 'AKBNK', 'ISCTR', 'KCHOL', 'SISE', 'EREGL', 'SAHOL', 'TUPRS', 'BIMAS', 'YKBNK', 'HALKB', 'VAKBN', 'PETKM', 'TCELL', 'ARCLK', 'FROTO', 'EKGYO', 'TOASO', 'SASA', 'HEKTS', 'ENKAI', 'MGROS', 'KOZAL', 'ODAS', 'ALARK', 'GUBRF', 'TKFEN', 'VESTL'],
    US: ['AAPL', 'MSFT', 'GOOGL', 'AMZN', 'TSLA', 'NVDA', 'META', 'BRK.B', 'UNH', 'JNJ', 'XOM', 'JPM', 'V', 'PG', 'MA', 'HD', 'CVX', 'ABBV', 'MRK', 'PEP', 'KO', 'LLY', 'BAC', 'AVGO', 'TMO', 'COST', 'DIS', 'PFE', 'CSCO', 'WMT'],
    COMMODITY: ['GOLD (XAU)', 'SILVER (XAG)', 'PLATINUM (XPT)', 'PALLADIUM', 'COPPER', 'OIL_WTI', 'OIL_BRENT', 'NAT_GAS']
};

/**
 * TECHNICAL INDICATOR ENGINE
 */
const Indicators = {
    ema: (data, period) => {
        let results = [];
        let k = 2 / (period + 1);
        let ema = data[0].close;
        for (let i = 0; i < data.length; i++) {
            if (i < period) {
                // SMA as initial EMA
                let sum = 0; for(let j=0; j<=i; j++) sum += data[j].close;
                ema = sum / (i+1);
            } else {
                ema = data[i].close * k + ema * (1 - k);
            }
            results.push(ema);
        }
        return results;
    },

    rsi: (data, period) => {
        let results = [];
        let gains = 0, losses = 0;
        for (let i = 0; i < data.length; i++) {
            if (i === 0) { results.push(null); continue; }
            let change = data[i].close - data[i-1].close;
            let gain = change > 0 ? change : 0;
            let loss = change < 0 ? -change : 0;

            if (i < period) {
                gains += gain; losses += loss;
                results.push(null);
            } else if (i === period) {
                gains /= period; losses /= period;
                let rs = gains / losses;
                results.push(100 - (100 / (1 + rs)));
            } else {
                gains = (gains * (period - 1) + gain) / period;
                losses = (losses * (period - 1) + loss) / period;
                let rs = gains / losses;
                results.push(losses === 0 ? 100 : 100 - (100 / (1 + rs)));
            }
        }
        return results;
    },

    superTrend: (data, period, factor) => {
        // ATR Calculation first
        let tr = [];
        for(let i=0; i<data.length; i++) {
            if(i==0) tr.push(data[i].high - data[i].low);
            else tr.push(Math.max(data[i].high - data[i].low, Math.abs(data[i].high - data[i-1].close), Math.abs(data[i].low - data[i-1].close)));
        }
        
        let atr = [];
        let sum = 0;
        for(let i=0; i<period; i++) sum += tr[i];
        atr[period-1] = sum / period;
        for(let i=period; i<data.length; i++) atr[i] = (atr[i-1]*(period-1) + tr[i])/period;

        // SuperTrend Calculation
        let st = [];
        for(let i=0; i<data.length; i++) {
            if(!atr[i]) { st.push({trend: 1, signal: null}); continue; }
            
            let hl2 = (data[i].high + data[i].low) / 2;
            let upper = hl2 + factor * atr[i];
            let lower = hl2 - factor * atr[i];
            
            let prev = st[i-1] || { upper: upper, lower: lower, trend: 1 };
            
            let finalUpper = (upper < prev.upper || data[i-1].close > prev.upper) ? upper : prev.upper;
            let finalLower = (lower > prev.lower || data[i-1].close < prev.lower) ? lower : prev.lower;

            let trend = prev.trend;
            let signal = null;

            if(trend === 1 && data[i].close < finalLower) {
                trend = -1; signal = 'SHORT';
            } else if(trend === -1 && data[i].close > finalUpper) {
                trend = 1; signal = 'LONG';
            }

            st.push({
                trend: trend,
                value: trend === 1 ? finalLower : finalUpper,
                upper: finalUpper,
                lower: finalLower,
                signal: signal
            });
        }
        return st;
    },

    macd: (data, fast, slow, signalP) => {
        const fastEMA = Indicators.ema(data, fast);
        const slowEMA = Indicators.ema(data, slow);
        let macdLine = [];
        for(let i=0; i<data.length; i++) macdLine.push(fastEMA[i] - slowEMA[i]);
        
        // Signal Line is EMA of MACD Line
        // We need to create a dummy object array for EMA function or rewrite EMA for simple array
        // Simple rewrite for simple array:
        let signalLine = [];
        let k = 2 / (signalP + 1);
        let ema = macdLine[0]; // Simplified start
        for(let i=0; i<macdLine.length; i++) {
            ema = macdLine[i] * k + ema * (1 - k);
            signalLine.push(ema);
        }
        
        return { macd: macdLine, signal: signalLine };
    },

    bollinger: (data, period, stdDev) => {
        let sma = [];
        let bands = [];
        
        for(let i=0; i<data.length; i++) {
            if(i < period - 1) { bands.push({}); continue; }
            
            let sum = 0;
            for(let j=0; j<period; j++) sum += data[i-j].close;
            let avg = sum / period;
            
            let sumSqDiff = 0;
            for(let j=0; j<period; j++) sumSqDiff += Math.pow(data[i-j].close - avg, 2);
            let sd = Math.sqrt(sumSqDiff / period);

            bands.push({
                middle: avg,
                upper: avg + (sd * stdDev),
                lower: avg - (sd * stdDev)
            });
        }
        return bands;
    }
};

/**
 * APPLICATION LOGIC
 */
const App = {
    chart: null,
    series: null,
    currentData: [],
    
    // UI Helpers
    params: {
        supertrend: [
            { id: 'st_period', label: 'ATR Period', type: 'number', val: 10, min: 1, max: 50 },
            { id: 'st_factor', label: 'Factor', type: 'number', val: 3, step: 0.1, min: 1, max: 10 }
        ],
        rsi: [
            { id: 'rsi_period', label: 'Period', type: 'number', val: 14, min: 2 },
            { id: 'rsi_overbought', label: 'Overbought', type: 'number', val: 70 },
            { id: 'rsi_oversold', label: 'Oversold', type: 'number', val: 30 }
        ],
        macd: [
            { id: 'macd_fast', label: 'Fast Length', type: 'number', val: 12 },
            { id: 'macd_slow', label: 'Slow Length', type: 'number', val: 26 },
            { id: 'macd_sig', label: 'Signal Length', type: 'number', val: 9 }
        ],
        ema: [
            { id: 'ema_fast', label: 'Fast EMA', type: 'number', val: 9 },
            { id: 'ema_slow', label: 'Slow EMA', type: 'number', val: 21 }
        ],
        bollinger: [
            { id: 'bb_period', label: 'Period', type: 'number', val: 20 },
            { id: 'bb_std', label: 'StdDev', type: 'number', val: 2 }
        ]
    },

    init: () => {
        App.initChart();
        App.populateSelects();
        App.renderParams();
        
        // Listeners
        document.getElementById('market').addEventListener('change', (e) => {
            App.populateSymbol(e.target.value);
        });
        document.getElementById('strategy').addEventListener('change', App.renderParams);
        
        // Initial Run
        App.start();
    },

    initChart: () => {
        const el = document.getElementById('chart');
        App.chart = LightweightCharts.createChart(el, {
            layout: { background: { color: '#131722' }, textColor: '#d1d4dc' },
            grid: { vertLines: { color: '#2a2e39' }, horzLines: { color: '#2a2e39' } },
            timeScale: { timeVisible: true, borderColor: '#2a2e39' },
            rightPriceScale: { borderColor: '#2a2e39' },
        });
        App.series = App.chart.addCandlestickSeries({
            upColor: '#089981', downColor: '#f23645', borderVisible: false, wickUpColor: '#089981', wickDownColor: '#f23645'
        });
        
        new ResizeObserver(() => App.chart.resize(el.clientWidth, el.clientHeight)).observe(el);
    },

    populateSelects: () => {
        App.populateSymbol('CRYPTO');
    },

    populateSymbol: (market) => {
        const sel = document.getElementById('symbol');
        sel.innerHTML = '';
        ASSETS[market].forEach(s => {
            let opt = document.createElement('option');
            opt.value = s; opt.text = s; sel.add(opt);
        });
    },

    renderParams: () => {
        const strat = document.getElementById('strategy').value;
        const container = document.getElementById('params-container');
        container.innerHTML = '';
        
        const config = App.params[strat];
        config.forEach(p => {
            let div = document.createElement('div');
            div.className = 'param-grid';
            div.innerHTML = `
                <label style="align-self:center">${p.label}</label>
                <input type="${p.type}" id="${p.id}" value="${p.val}" step="${p.step||1}">
            `;
            container.appendChild(div);
        });
    },

    getParamsValues: () => {
        const strat = document.getElementById('strategy').value;
        let vals = {};
        App.params[strat].forEach(p => {
            vals[p.id] = parseFloat(document.getElementById(p.id).value);
        });
        return vals;
    },

    // Mock Data Generator for Non-Crypto
    generateData: (limit) => {
        let data = [];
        let price = 100 + Math.random() * 50;
        let time = Math.floor(Date.now()/1000) - (limit*3600);
        for(let i=0; i<limit; i++) {
            let chg = (Math.random() - 0.5) * 2;
            let close = price + chg;
            let open = price;
            let high = Math.max(open, close) + Math.random();
            let low = Math.min(open, close) - Math.random();
            data.push({ time, open, high, low, close });
            price = close;
            time += 3600;
        }
        return data;
    },

    fetchData: async () => {
        const market = document.getElementById('market').value;
        const symbol = document.getElementById('symbol').value;
        const interval = document.getElementById('interval').value;
        
        if(market === 'CRYPTO') {
            const res = await fetch(`https://api.binance.com/api/v3/klines?symbol=${symbol}&interval=${interval}&limit=500`);
            const json = await res.json();
            return json.map(d => ({
                time: d[0]/1000, open: parseFloat(d[1]), high: parseFloat(d[2]), low: parseFloat(d[3]), close: parseFloat(d[4])
            }));
        } else {
            // Simulation Data
            await new Promise(r => setTimeout(r, 400));
            return App.generateData(500);
        }
    },

    start: async () => {
        document.getElementById('loading').style.display = 'flex';
        try {
            const data = await App.fetchData();
            App.currentData = data;
            
            const params = App.getParamsValues();
            const stratName = document.getElementById('strategy').value;
            
            const result = Backtest.run(data, stratName, params);
            
            // Draw
            App.series.setData(data);
            App.series.setMarkers(result.markers);
            App.chart.timeScale().fitContent();
            
            // Stats
            document.getElementById('res-balance').innerText = '$' + result.balance.toFixed(2);
            document.getElementById('res-pnl').innerText = '$' + (result.balance - parseFloat(document.getElementById('balance').value)).toFixed(2);
            document.getElementById('res-pnl').className = 'stat-val ' + (result.balance >= parseFloat(document.getElementById('balance').value) ? 'profit' : 'loss');
            document.getElementById('res-win').innerText = '%' + result.winRate;
            document.getElementById('res-trades').innerText = result.totalTrades;
            
        } catch(e) {
            console.error(e);
            alert('Hata oluştu: ' + e.message);
        } finally {
            document.getElementById('loading').style.display = 'none';
        }
    }
};

/**
 * BACKTEST ENGINE
 */
const Backtest = {
    run: (data, strategyName, params) => {
        let balance = parseFloat(document.getElementById('balance').value);
        let position = null; 
        let trades = 0;
        let wins = 0;
        let markers = [];
        
        // Calculate Indicators based on strategy
        let signals = [];
        
        if (strategyName === 'supertrend') {
            const st = Indicators.superTrend(data, params.st_period, params.st_factor);
            signals = st.map(s => s.signal);
        } else if (strategyName === 'rsi') {
            const rsi = Indicators.rsi(data, params.rsi_period);
            for(let i=1; i<data.length; i++) {
                if(rsi[i-1] < params.rsi_oversold && rsi[i] >= params.rsi_oversold) signals[i] = 'LONG';
                else if(rsi[i-1] > params.rsi_overbought && rsi[i] <= params.rsi_overbought) signals[i] = 'SHORT';
                else signals[i] = null;
            }
        } else if (strategyName === 'ema') {
            const fast = Indicators.ema(data, params.ema_fast);
            const slow = Indicators.ema(data, params.ema_slow);
            for(let i=1; i<data.length; i++) {
                if(fast[i-1] < slow[i-1] && fast[i] > slow[i]) signals[i] = 'LONG';
                else if(fast[i-1] > slow[i-1] && fast[i] < slow[i]) signals[i] = 'SHORT';
            }
        } else if (strategyName === 'macd') {
            const m = Indicators.macd(data, params.macd_fast, params.macd_slow, params.macd_sig);
            for(let i=1; i<data.length; i++) {
                if(m.macd[i-1] < m.signal[i-1] && m.macd[i] > m.signal[i]) signals[i] = 'LONG';
                else if(m.macd[i-1] > m.signal[i-1] && m.macd[i] < m.signal[i]) signals[i] = 'SHORT';
            }
        } else if (strategyName === 'bollinger') {
            const bb = Indicators.bollinger(data, params.bb_period, params.bb_std);
            for(let i=1; i<data.length; i++) {
                if(!bb[i].lower) continue;
                if(data[i].close < bb[i].lower) signals[i] = 'LONG'; // Mean Reversion Buy
                else if(data[i].close > bb[i].upper) signals[i] = 'SHORT'; // Mean Reversion Sell
            }
        }

        // Execute Trades
        for(let i = 50; i < data.length; i++) { // Skip warmup
            const sig = signals[i];
            const price = data[i].close;
            const time = data[i].time;

            if(position) {
                // Close Logic (Reverse Signal)
                if((position.type === 'LONG' && sig === 'SHORT') || (position.type === 'SHORT' && sig === 'LONG')) {
                    let pnl = (position.type === 'LONG') ? (price - position.entry) : (position.entry - price);
                    pnl = pnl * position.amount;
                    balance += pnl;
                    if(pnl > 0) wins++;
                    trades++;
                    
                    markers.push({ time: time, position: position.type === 'LONG' ? 'aboveBar' : 'belowBar', color: '#e1e3eb', shape: 'circle', text: 'Exit' });
                    position = null; 
                }
            }

            if(!position && sig) {
                position = { type: sig, entry: price, amount: balance / price };
                markers.push({ 
                    time: time, 
                    position: sig === 'LONG' ? 'belowBar' : 'aboveBar', 
                    color: sig === 'LONG' ? '#089981' : '#f23645', 
                    shape: sig === 'LONG' ? 'arrowUp' : 'arrowDown', 
                    text: sig 
                });
            }
        }
        
        // Final close
        if(position) {
            let price = data[data.length-1].close;
            let pnl = (position.type === 'LONG') ? (price - position.entry) : (position.entry - price);
            balance += (pnl * position.amount);
            trades++;
            if((pnl * position.amount) > 0) wins++;
        }

        return {
            balance: balance,
            totalTrades: trades,
            winRate: trades > 0 ? Math.round((wins/trades)*100) : 0,
            markers: markers
        };
    }
};

/**
 * OPTIMIZER ENGINE (Brute Force)
 */
const Optimizer = {
    run: async () => {
        const strat = document.getElementById('strategy').value;
        const statusEl = document.getElementById('opt-status');
        const data = App.currentData;
        
        if(data.length === 0) { alert("Önce veriyi çekin (Çalıştır'a basın)"); return; }

        statusEl.innerText = "Optimizasyon Başlıyor...";
        
        // Define Search Space
        let variations = [];
        
        if(strat === 'supertrend') {
            for(let p=7; p<=21; p+=3) {
                for(let f=1; f<=5; f+=0.5) {
                    variations.push({ st_period: p, st_factor: f });
                }
            }
        } else if (strat === 'rsi') {
            for(let p=7; p<=21; p+=2) {
                for(let ob=65; ob<=85; ob+=5) {
                    for(let os=15; os<=35; os+=5) {
                        variations.push({ rsi_period: p, rsi_overbought: ob, rsi_oversold: os });
                    }
                }
            }
        } else if (strat === 'ema') {
            for(let f=5; f<=20; f+=5) {
                for(let s=20; s<=100; s+=20) {
                    if(s > f) variations.push({ ema_fast: f, ema_slow: s });
                }
            }
        }
        
        if(variations.length === 0) {
            statusEl.innerText = "Bu strateji için optimizasyon tanımlı değil.";
            return;
        }

        let bestPnL = -Infinity;
        let bestParams = null;

        // Async Loop to prevent UI Freezing
        for(let i=0; i<variations.length; i++) {
            const v = variations[i];
            statusEl.innerText = `Deneniyor: ${i+1}/${variations.length}`;
            
            // Non-blocking wait
            if(i % 10 === 0) await new Promise(r => setTimeout(r, 0));

            const res = Backtest.run(data, strat, v);
            if(res.balance > bestPnL) {
                bestPnL = res.balance;
                bestParams = v;
            }
        }

        statusEl.innerText = "En İyi Ayarlar Bulundu!";
        
        // Apply Best Params to UI
        for(let key in bestParams) {
            if(document.getElementById(key)) {
                document.getElementById(key).value = bestParams[key];
            }
        }
        
        // Rerun with best
        App.start();
        alert(`Optimizasyon Tamamlandı!\nEn Yüksek Bakiye: $${bestPnL.toFixed(2)}\nAyarlar güncellendi.`);
    }
};

// Start App
window.addEventListener('DOMContentLoaded', App.init);

</script>
</body>
</html>