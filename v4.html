<!DOCTYPE html>
<html lang="tr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ProTrade AI - Ultimate Trading Dashboard</title>
    <script src="https://unpkg.com/lightweight-charts@4.1.1/dist/lightweight-charts.standalone.production.js"></script>
    <style>
        :root {
            --bg-dark: #0b0e11;
            --bg-panel: #151924;
            --bg-hover: #2a2e39;
            --border: #2a2e39;
            --text-main: #EAECEF;
            --text-dim: #848E9C;
            --accent: #2962ff;
            --green: #0ECB81;
            --red: #F6465D;
            --font: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
        }

        * { box-sizing: border-box; outline: none; }
        
        body { margin: 0; background: var(--bg-dark); color: var(--text-main); font-family: var(--font); display: flex; height: 100vh; overflow: hidden; font-size: 13px; }
        
        /* --- SIDEBAR --- */
        aside { 
            width: 300px; 
            background: var(--bg-panel); 
            border-right: 1px solid var(--border); 
            display: flex; flex-direction: column; 
            overflow-y: auto; 
            flex-shrink: 0;
        }
        
        .sidebar-header { padding: 15px; border-bottom: 1px solid var(--border); font-weight: 800; font-size: 1.1rem; color: var(--text-main); letter-spacing: 0.5px; }
        .sidebar-header span { color: var(--accent); }
        
        .control-section { padding: 15px; border-bottom: 1px solid var(--border); }
        .section-title { margin: 0 0 10px 0; font-size: 0.75rem; color: var(--text-dim); text-transform: uppercase; font-weight: 700; letter-spacing: 0.5px; }
        
        label { display: block; font-size: 0.8rem; margin-bottom: 4px; color: var(--text-dim); }
        select, input { 
            width: 100%; background: var(--bg-dark); border: 1px solid var(--border); 
            color: var(--text-main); padding: 8px; border-radius: 4px; margin-bottom: 10px; 
            font-family: var(--font); font-size: 0.85rem; transition: 0.2s;
        }
        select:focus, input:focus { border-color: var(--accent); }
        
        /* Buttons */
        .btn-group { display: flex; gap: 5px; margin-top: 5px; }
        button { 
            flex: 1; padding: 10px; border: none; border-radius: 4px; 
            cursor: pointer; font-weight: 600; transition: 0.2s; font-size: 0.85rem;
        }
        .btn-primary { background: var(--accent); color: white; }
        .btn-primary:hover { background: #1e54e6; }
        .btn-secondary { background: #333; color: white; }
        .btn-secondary:hover { background: #444; }
        .btn-opt { background: linear-gradient(135deg, #673ab7, #512da8); color: white; width: 100%; margin-top: 5px; }
        
        /* Optimization Progress */
        #opt-progress-container { display: none; margin-top: 10px; }
        progress { width: 100%; height: 6px; border-radius: 3px; }
        #opt-status-text { font-size: 0.75rem; color: var(--text-dim); text-align: center; margin-top: 2px; }

        /* Dynamic Params */
        .param-row { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; align-items: end; }
        
        /* --- MAIN CONTENT --- */
        main { flex: 1; display: flex; flex-direction: column; position: relative; min-width: 0; }
        
        /* Chart Area */
        #chart-container { flex: 2; position: relative; width: 100%; }
        #chart { width: 100%; height: 100%; }
        
        /* Stats Bar */
        .stats-bar { 
            height: 60px; background: var(--bg-panel); border-top: 1px solid var(--border); border-bottom: 1px solid var(--border);
            display: flex; align-items: center; justify-content: space-evenly; flex-shrink: 0;
        }
        .stat-item { text-align: center; }
        .stat-label { font-size: 0.7rem; color: var(--text-dim); margin-bottom: 2px; }
        .stat-value { font-size: 1.1rem; font-weight: 700; color: var(--text-main); }
        .val-green { color: var(--green); }
        .val-red { color: var(--red); }

        /* History Table */
        #history-panel { flex: 1; background: var(--bg-dark); overflow: hidden; display: flex; flex-direction: column; min-height: 200px; }
        .panel-header { 
            padding: 8px 15px; background: var(--bg-panel); border-bottom: 1px solid var(--border); 
            font-weight: 600; color: var(--text-main); display: flex; justify-content: space-between;
        }
        .table-container { flex: 1; overflow-y: auto; }
        
        table { width: 100%; border-collapse: collapse; font-size: 0.85rem; }
        th { position: sticky; top: 0; background: var(--bg-panel); color: var(--text-dim); font-weight: 600; text-align: left; padding: 8px 15px; z-index: 2; }
        td { padding: 6px 15px; border-bottom: 1px solid var(--border); color: var(--text-main); }
        tr:hover { background: var(--bg-hover); }
        
        .badge { padding: 2px 6px; border-radius: 3px; font-size: 0.7rem; font-weight: 700; text-transform: uppercase; }
        .badge-long { background: rgba(14, 203, 129, 0.15); color: var(--green); }
        .badge-short { background: rgba(246, 70, 93, 0.15); color: var(--red); }

        /* Loader */
        #loader { 
            position: absolute; top: 0; left: 0; right: 0; bottom: 0; 
            background: rgba(11, 14, 17, 0.85); z-index: 50; display: none; 
            align-items: center; justify-content: center; flex-direction: column;
        }
        .spinner { width: 30px; height: 30px; border: 3px solid var(--border); border-top: 3px solid var(--accent); border-radius: 50%; animation: spin 0.8s linear infinite; }
        @keyframes spin { to { transform: rotate(360deg); } }
    </style>
</head>
<body>

<aside>
    <div class="sidebar-header">ProTrade <span>Ultimate</span></div>
    
    <div class="control-section">
        <div class="section-title">Piyasa Ayarları</div>
        <label>Veri Kaynağı</label>
        <select id="market-type">
            <option value="CRYPTO">Kripto (Binance Canlı)</option>
            <option value="BIST">BIST 30 (Simülasyon)</option>
            <option value="US">ABD Borsası (Simülasyon)</option>
            <option value="COMMODITY">Emtia (Simülasyon)</option>
        </select>
        
        <label>Varlık</label>
        <select id="asset-symbol"></select>
        
        <div class="param-row">
            <div>
                <label>Periyot</label>
                <select id="timeframe">
                    <option value="15m">15 Dakika</option>
                    <option value="1h">1 Saat</option>
                    <option value="4h" selected>4 Saat</option>
                    <option value="1d">1 Gün</option>
                </select>
            </div>
            <div>
                <label>Oto Yenile</label>
                <select id="auto-refresh">
                    <option value="0">Kapalı</option>
                    <option value="10000">10 Sn</option>
                    <option value="30000">30 Sn</option>
                    <option value="60000">1 Dk</option>
                </select>
            </div>
        </div>
    </div>

    <div class="control-section">
        <div class="section-title">Strateji Motoru</div>
        <label>Aktif Strateji</label>
        <select id="strategy-select">
            <option value="supertrend">SuperTrend</option>
            <option value="turtle">Turtle Trading</option>
            <option value="rsi">RSI Reversal</option>
            <option value="macd">MACD Momentum</option>
            <option value="bollinger">Bollinger Breakout</option>
        </select>
        
        <!-- Dinamik Parametreler Buraya Gelecek -->
        <div id="dynamic-params"></div>
    </div>

    <div class="control-section">
        <div class="section-title">Backtest & Optimizasyon</div>
        <label>Başlangıç Bakiyesi ($)</label>
        <input type="number" id="initial-capital" value="1000">
        
        <div class="btn-group">
            <button class="btn-primary" onclick="App.run()">Analiz Et</button>
        </div>
        
        <button class="btn-opt" onclick="Optimizer.start()">⚡ AI Optimize Et</button>
        
        <div id="opt-progress-container">
            <progress id="opt-bar" value="0" max="100"></progress>
            <div id="opt-status-text">Aranıyor...</div>
        </div>
    </div>
</aside>

<main>
    <div id="loader">
        <div class="spinner"></div>
        <div style="margin-top:10px; color:#848E9C;">Veriler İşleniyor...</div>
    </div>

    <div id="chart-container">
        <div id="chart"></div>
    </div>

    <div class="stats-bar">
        <div class="stat-item">
            <div class="stat-label">Toplam Bakiye</div>
            <div class="stat-value" id="stat-balance">---</div>
        </div>
        <div class="stat-item">
            <div class="stat-label">Net PnL</div>
            <div class="stat-value" id="stat-pnl">---</div>
        </div>
        <div class="stat-item">
            <div class="stat-label">Kazanma Oranı</div>
            <div class="stat-value" id="stat-winrate">---</div>
        </div>
        <div class="stat-item">
            <div class="stat-label">Toplam İşlem</div>
            <div class="stat-value" id="stat-trades">---</div>
        </div>
    </div>

    <div id="history-panel">
        <div class="panel-header">
            <span>İşlem Geçmişi</span>
            <span style="font-size:0.75rem; font-weight:normal; opacity:0.7">Son 100 İşlem</span>
        </div>
        <div class="table-container">
            <table id="trade-table">
                <thead>
                    <tr>
                        <th>Tip</th>
                        <th>Giriş Tarihi</th>
                        <th>Giriş Fiyatı</th>
                        <th>Çıkış Tarihi</th>
                        <th>Çıkış Fiyatı</th>
                        <th>Kâr/Zarar</th>
                    </tr>
                </thead>
                <tbody>
                    <!-- JS ile dolacak -->
                </tbody>
            </table>
        </div>
    </div>
</main>

<script>
/**
 * --- UTILS & CONFIG ---
 */
// Seeded Random Class for Consistency
class SeededRandom {
    constructor(seedString) {
        this.seed = 0;
        for(let i=0; i<seedString.length; i++) this.seed += seedString.charCodeAt(i);
    }
    next() {
        const x = Math.sin(this.seed++) * 10000;
        return x - Math.floor(x);
    }
    range(min, max) { return min + (this.next() * (max - min)); }
}

const ASSETS = {
    CRYPTO: ['BTCUSDT', 'ETHUSDT', 'SOLUSDT', 'XRPUSDT', 'AVAXUSDT', 'DOGEUSDT', 'BNBUSDT', 'ADAUSDT'],
    BIST: ['THYAO', 'ASELS', 'GARAN', 'AKBNK', 'SISE', 'EREGL', 'KCHOL', 'SAHOL', 'TUPRS', 'BIMAS'],
    US: ['AAPL', 'MSFT', 'NVDA', 'TSLA', 'AMZN', 'GOOGL', 'META', 'AMD', 'NFLX', 'INTC'],
    COMMODITY: ['GOLD', 'SILVER', 'BRENT_OIL', 'NAT_GAS', 'COPPER']
};

/**
 * --- INDICATOR ENGINE (Corrected Logic) ---
 */
const Indicators = {
    // 1. Fixed SuperTrend (Matching TradingView logic exactly)
    superTrend: (data, period, multiplier) => {
        let st = [];
        // ATR Calculation
        let tr = [0];
        for(let i=1; i<data.length; i++) {
            let hl = data[i].high - data[i].low;
            let hc = Math.abs(data[i].high - data[i-1].close);
            let lc = Math.abs(data[i].low - data[i-1].close);
            tr.push(Math.max(hl, hc, lc));
        }
        
        // Simple MA for first ATR
        let atr = new Array(data.length).fill(0);
        let sum = 0;
        for(let i=0; i<period; i++) sum += tr[i];
        atr[period-1] = sum / period;
        
        // Smoothed ATR
        for(let i=period; i<data.length; i++) {
            atr[i] = (atr[i-1] * (period - 1) + tr[i]) / period;
        }

        // SuperTrend Logic
        let basicUpper, basicLower;
        let finalUpper = 0, finalLower = 0;
        let trend = 1; // 1: Long, -1: Short

        for(let i=0; i<data.length; i++) {
            if(i < period) { st.push({trend:1, signal: null}); continue; }

            let hl2 = (data[i].high + data[i].low) / 2;
            basicUpper = hl2 + (multiplier * atr[i]);
            basicLower = hl2 - (multiplier * atr[i]);

            let prevFinalUpper = (st[i-1] && st[i-1].upper) ? st[i-1].upper : 0;
            let prevFinalLower = (st[i-1] && st[i-1].lower) ? st[i-1].lower : 0;
            let prevTrend = (st[i-1] && st[i-1].trend) ? st[i-1].trend : 1;
            let prevClose = data[i-1].close;

            // Final Band Calculation
            if(basicUpper < prevFinalUpper || prevClose > prevFinalUpper) finalUpper = basicUpper;
            else finalUpper = prevFinalUpper;

            if(basicLower > prevFinalLower || prevClose < prevFinalLower) finalLower = basicLower;
            else finalLower = prevFinalLower;

            // Trend Switch Logic
            trend = prevTrend;
            if(trend === 1 && data[i].close < finalLower) {
                trend = -1;
            } else if(trend === -1 && data[i].close > finalUpper) {
                trend = 1;
            }

            // Detect Signal (Only on change)
            let signal = null;
            if(trend === 1 && prevTrend === -1) signal = 'LONG';
            if(trend === -1 && prevTrend === 1) signal = 'SHORT';

            st.push({
                trend: trend,
                upper: finalUpper,
                lower: finalLower,
                signal: signal
            });
        }
        return st;
    },

    turtle: (data, entryPeriod, exitPeriod) => {
        let results = [];
        for(let i=0; i<data.length; i++) {
            if(i < entryPeriod) { results.push({signal: null}); continue; }
            
            const entrySlice = data.slice(i-entryPeriod, i);
            const exitSlice = data.slice(i-exitPeriod, i);
            
            const entryHigh = Math.max(...entrySlice.map(d=>d.high));
            const entryLow = Math.min(...entrySlice.map(d=>d.low));
            
            const exitHigh = Math.max(...exitSlice.map(d=>d.high)); // Short exit
            const exitLow = Math.min(...exitSlice.map(d=>d.low));   // Long exit
            
            let signal = null;
            // Breakout Long
            if(data[i].close > entryHigh) signal = 'LONG';
            // Breakout Short
            else if(data[i].close < entryLow) signal = 'SHORT';
            // Exit signals handled in backtest logic usually, but here we provide raw signals
            
            results.push({ signal, exitHigh, exitLow });
        }
        return results;
    },

    rsi: (data, period) => {
        // ... Standard RSI ...
        let results = [];
        let gains = 0, losses = 0;
        for(let i=0; i<data.length; i++) {
            if(i===0) { results.push(50); continue; }
            let diff = data[i].close - data[i-1].close;
            let gain = diff > 0 ? diff : 0;
            let loss = diff < 0 ? -diff : 0;
            
            if(i < period) {
                gains += gain; losses += loss;
                results.push(50);
            } else if (i===period) {
                gains /= period; losses /= period;
                results.push(100 - (100/(1+(gains/losses))));
            } else {
                gains = (gains*(period-1)+gain)/period;
                losses = (losses*(period-1)+loss)/period;
                results.push(100 - (100/(1+(gains/losses))));
            }
        }
        return results;
    },

    ema: (data, period) => {
        let res = [];
        let k = 2/(period+1);
        let ema = data[0].close;
        for(let i=0; i<data.length; i++) {
            ema = data[i].close * k + ema * (1-k);
            res.push(ema);
        }
        return res;
    },
    
    macd: (data, fast, slow, sig) => {
        const emaFast = Indicators.ema(data, fast);
        const emaSlow = Indicators.ema(data, slow);
        let macdLine = data.map((d,i) => emaFast[i] - emaSlow[i]);
        
        let signalLine = [];
        let k = 2/(sig+1);
        let val = macdLine[0];
        for(let i=0; i<macdLine.length; i++) {
            val = macdLine[i]*k + val*(1-k);
            signalLine.push(val);
        }
        return { macd: macdLine, signal: signalLine };
    },

    bollinger: (data, period, std) => {
        let res = [];
        for(let i=0; i<data.length; i++) {
            if(i<period) { res.push({upper:0, lower:0}); continue; }
            let slice = data.slice(i-period+1, i+1);
            let mean = slice.reduce((a,b)=>a+b.close,0)/period;
            let sqDiff = slice.reduce((a,b)=>a + Math.pow(b.close-mean, 2), 0);
            let dev = Math.sqrt(sqDiff/period);
            res.push({ upper: mean + dev*std, lower: mean - dev*std });
        }
        return res;
    }
};

/**
 * --- MAIN APP ---
 */
const App = {
    chart: null,
    candleSeries: null,
    volumeSeries: null,
    data: [],
    refreshInterval: null,
    
    // Parameter Definitions
    paramsDef: {
        supertrend: [
            { id: 'st_period', label: 'ATR Period', type: 'number', val: 10, min: 1 },
            { id: 'st_factor', label: 'Factor', type: 'number', val: 3, step: 0.1 }
        ],
        turtle: [
            { id: 'tt_entry', label: 'Giriş Periyodu', type: 'number', val: 20 },
            { id: 'tt_exit', label: 'Çıkış Periyodu', type: 'number', val: 10 }
        ],
        rsi: [
            { id: 'rsi_len', label: 'Uzunluk', type: 'number', val: 14 },
            { id: 'rsi_ob', label: 'Aşırı Alım', type: 'number', val: 70 },
            { id: 'rsi_os', label: 'Aşırı Satım', type: 'number', val: 30 }
        ],
        macd: [
            { id: 'm_fast', label: 'Fast EMA', type: 'number', val: 12 },
            { id: 'm_slow', label: 'Slow EMA', type: 'number', val: 26 },
            { id: 'm_sig', label: 'Signal', type: 'number', val: 9 }
        ],
        bollinger: [
            { id: 'bb_len', label: 'Periyot', type: 'number', val: 20 },
            { id: 'bb_std', label: 'Std Dev', type: 'number', val: 2 }
        ]
    },

    init: () => {
        App.initChart();
        App.bindEvents();
        App.renderParams(); // Initial render
        App.run();
    },

    initChart: () => {
        const el = document.getElementById('chart');
        App.chart = LightweightCharts.createChart(el, {
            layout: { background: { color: '#0b0e11' }, textColor: '#848E9C' },
            grid: { vertLines: { color: '#151924' }, horzLines: { color: '#151924' } },
            timeScale: { borderColor: '#2a2e39', timeVisible: true },
            rightPriceScale: { borderColor: '#2a2e39', scaleMargins: { top: 0.1, bottom: 0.2 } },
        });
        
        // Volume Series (histogram)
        App.volumeSeries = App.chart.addHistogramSeries({
            color: '#26a69a',
            priceFormat: { type: 'volume' },
            priceScaleId: '', // Overlay
            scaleMargins: { top: 0.8, bottom: 0 },
        });

        // Candle Series
        App.candleSeries = App.chart.addCandlestickSeries({
            upColor: '#0ECB81', downColor: '#F6465D',
            borderVisible: false, wickUpColor: '#0ECB81', wickDownColor: '#F6465D'
        });

        new ResizeObserver(() => App.chart.resize(el.clientWidth, el.clientHeight)).observe(el);
    },

    bindEvents: () => {
        // Dynamic Dropdowns
        const marketSel = document.getElementById('market-type');
        const assetSel = document.getElementById('asset-symbol');
        
        const populateAssets = () => {
            assetSel.innerHTML = '';
            ASSETS[marketSel.value].forEach(s => {
                let o = document.createElement('option');
                o.value = s; o.text = s; assetSel.add(o);
            });
        };
        
        marketSel.addEventListener('change', populateAssets);
        populateAssets(); // Init

        // Strategy Change
        document.getElementById('strategy-select').addEventListener('change', App.renderParams);

        // Auto Refresh Logic
        document.getElementById('auto-refresh').addEventListener('change', (e) => {
            const ms = parseInt(e.target.value);
            if(App.refreshInterval) clearInterval(App.refreshInterval);
            if(ms > 0) {
                App.refreshInterval = setInterval(() => App.run(true), ms);
            }
        });
    },

    renderParams: () => {
        const strat = document.getElementById('strategy-select').value;
        const container = document.getElementById('dynamic-params');
        container.innerHTML = '';
        
        App.paramsDef[strat].forEach(p => {
            let div = document.createElement('div');
            div.className = 'param-row';
            div.innerHTML = `
                <label>${p.label}</label>
                <input type="${p.type}" id="${p.id}" value="${p.val}" step="${p.step || 1}">
            `;
            container.appendChild(div);
        });
    },

    getParamsValues: () => {
        const strat = document.getElementById('strategy-select').value;
        let p = {};
        App.paramsDef[strat].forEach(def => {
            p[def.id] = parseFloat(document.getElementById(def.id).value);
        });
        return p;
    },

    fetchData: async () => {
        const type = document.getElementById('market-type').value;
        const symbol = document.getElementById('asset-symbol').value;
        const interval = document.getElementById('timeframe').value;
        
        if(type === 'CRYPTO') {
            const res = await fetch(`https://api.binance.com/api/v3/klines?symbol=${symbol}&interval=${interval}&limit=500`);
            const json = await res.json();
            return json.map(d => ({
                time: d[0]/1000,
                open: parseFloat(d[1]), high: parseFloat(d[2]),
                low: parseFloat(d[3]), close: parseFloat(d[4]),
                value: parseFloat(d[5]), color: parseFloat(d[4])>=parseFloat(d[1])?'rgba(14, 203, 129, 0.3)':'rgba(246, 70, 93, 0.3)' // Volume color
            }));
        } else {
            // Seeded Simulation
            await new Promise(r => setTimeout(r, 200)); // Network delay sim
            const rng = new SeededRandom(symbol); // Constant seed per symbol
            let data = [];
            let price = 100 + rng.range(0, 50);
            let time = Math.floor(Date.now()/1000) - (500 * (interval==='15m'?900:3600));
            
            for(let i=0; i<500; i++) {
                let move = rng.range(-2.5, 2.6);
                let close = price + move;
                let open = price;
                let high = Math.max(open, close) + rng.range(0, 1.5);
                let low = Math.min(open, close) - rng.range(0, 1.5);
                let vol = rng.range(1000, 5000);
                
                data.push({ 
                    time, open, high, low, close, 
                    value: vol, color: close>=open?'rgba(14, 203, 129, 0.3)':'rgba(246, 70, 93, 0.3)' 
                });
                price = close;
                time += (interval==='15m'?900:3600);
            }
            return data;
        }
    },

    run: async (isAutoRefresh = false) => {
        if(!isAutoRefresh) document.getElementById('loader').style.display = 'flex';
        
        try {
            const data = await App.fetchData();
            App.data = data;
            
            const strategy = document.getElementById('strategy-select').value;
            const params = App.getParamsValues();
            
            // 1. Calculate Backtest
            const result = Backtest.run(data, strategy, params);
            
            // 2. Render Chart
            App.candleSeries.setData(data);
            App.volumeSeries.setData(data.map(d => ({ time: d.time, value: d.value, color: d.color })));
            
            // Markers
            App.candleSeries.setMarkers(result.markers);
            if(!isAutoRefresh) App.chart.timeScale().fitContent();
            
            // 3. Update Stats
            App.updateStats(result);
            
            // 4. Update Table
            App.updateTable(result.trades);
            
        } catch(e) {
            console.error(e);
            alert("Hata: " + e.message);
        } finally {
            document.getElementById('loader').style.display = 'none';
        }
    },

    updateStats: (res) => {
        const balEl = document.getElementById('stat-balance');
        const pnlEl = document.getElementById('stat-pnl');
        const initial = parseFloat(document.getElementById('initial-capital').value);
        const pnl = res.balance - initial;
        
        balEl.innerText = '$' + res.balance.toFixed(2);
        pnlEl.innerText = (pnl>=0?'+':'') + '$' + pnl.toFixed(2);
        pnlEl.className = 'stat-value ' + (pnl>=0?'val-green':'val-red');
        
        document.getElementById('stat-winrate').innerText = '%' + res.winRate;
        document.getElementById('stat-trades').innerText = res.totalTrades;
    },

    updateTable: (trades) => {
        const tbody = document.querySelector('#trade-table tbody');
        tbody.innerHTML = '';
        
        [...trades].reverse().forEach(t => {
            const row = document.createElement('tr');
            const formatTime = (ts) => new Date(ts*1000).toLocaleString('tr-TR', {month:'numeric', day:'numeric', hour:'2-digit', minute:'2-digit'});
            
            row.innerHTML = `
                <td><span class="badge ${t.type==='LONG'?'badge-long':'badge-short'}">${t.type}</span></td>
                <td>${formatTime(t.entryTime)}</td>
                <td>${t.entryPrice.toFixed(2)}</td>
                <td>${formatTime(t.exitTime)}</td>
                <td>${t.exitPrice.toFixed(2)}</td>
                <td class="${t.pnl>=0?'val-green':'val-red'}">${t.pnl>=0?'+':''}${t.pnl.toFixed(2)}</td>
            `;
            tbody.appendChild(row);
        });
    }
};

/**
 * --- BACKTEST LOGIC ---
 */
const Backtest = {
    run: (data, strat, p) => {
        let signals = new Array(data.length).fill(null);

        // Generate Signals
        if(strat === 'supertrend') {
            const st = Indicators.superTrend(data, p.st_period, p.st_factor);
            signals = st.map(s => s.signal);
        } else if(strat === 'turtle') {
            const t = Indicators.turtle(data, p.tt_entry, p.tt_exit);
            // Turtle logic: Enter on signal, Exit if price crosses opposite channel
            // Simplified: Use generated signals for entry, reverse logic handled below
            signals = t.map(x => x.signal);
        } else if(strat === 'rsi') {
            const r = Indicators.rsi(data, p.rsi_len);
            for(let i=1; i<data.length; i++) {
                if(r[i-1]<p.rsi_os && r[i]>=p.rsi_os) signals[i] = 'LONG';
                if(r[i-1]>p.rsi_ob && r[i]<=p.rsi_ob) signals[i] = 'SHORT';
            }
        } else if(strat === 'macd') {
            const m = Indicators.macd(data, p.m_fast, p.m_slow, p.m_sig);
            for(let i=1; i<data.length; i++) {
                if(m.macd[i-1]<m.signal[i-1] && m.macd[i]>m.signal[i]) signals[i] = 'LONG';
                if(m.macd[i-1]>m.signal[i-1] && m.macd[i]<m.signal[i]) signals[i] = 'SHORT';
            }
        } else if(strat === 'bollinger') {
            const bb = Indicators.bollinger(data, p.bb_len, p.bb_std);
            for(let i=1; i<data.length; i++) {
                if(data[i].close < bb[i].lower) signals[i] = 'LONG';
                if(data[i].close > bb[i].upper) signals[i] = 'SHORT';
            }
        }

        // Execute Trades
        let balance = parseFloat(document.getElementById('initial-capital').value);
        let position = null;
        let tradeLog = [];
        let markers = [];
        let wins = 0;

        for(let i=1; i<data.length; i++) { // Start from 1 to avoid index errors
            const sig = signals[i];
            const price = data[i].close;
            const time = data[i].time;

            if(position) {
                // Exit Condition: Reverse signal
                if((position.type === 'LONG' && sig === 'SHORT') || (position.type === 'SHORT' && sig === 'LONG')) {
                    const pnl = (position.type === 'LONG' ? price - position.entryPrice : position.entryPrice - price) * position.amount;
                    balance += pnl;
                    if(pnl > 0) wins++;
                    
                    tradeLog.push({
                        type: position.type,
                        entryTime: position.entryTime, entryPrice: position.entryPrice,
                        exitTime: time, exitPrice: price,
                        pnl: pnl
                    });

                    markers.push({ time, position: position.type==='LONG'?'aboveBar':'belowBar', color: '#EAECEF', shape: 'circle', text: 'Çıkış' });
                    position = null;
                }
            }

            if(!position && sig) {
                // Entry Condition
                position = {
                    type: sig,
                    entryPrice: price,
                    entryTime: time,
                    amount: balance / price
                };
                markers.push({
                    time, 
                    position: sig==='LONG'?'belowBar':'aboveBar', 
                    color: sig==='LONG'?'#0ECB81':'#F6465D', 
                    shape: sig==='LONG'?'arrowUp':'arrowDown', 
                    text: sig 
                });
            }
        }
        
        // Open Position handling at end
        if(position) {
             const price = data[data.length-1].close;
             const pnl = (position.type === 'LONG' ? price - position.entryPrice : position.entryPrice - price) * position.amount;
             tradeLog.push({
                type: position.type + ' (AÇIK)',
                entryTime: position.entryTime, entryPrice: position.entryPrice,
                exitTime: data[data.length-1].time, exitPrice: price,
                pnl: pnl
            });
        }

        return {
            balance,
            totalTrades: tradeLog.length,
            winRate: tradeLog.length > 0 ? Math.round((wins/tradeLog.length)*100) : 0,
            trades: tradeLog,
            markers
        };
    }
};

/**
 * --- OPTIMIZER (Expanded) ---
 */
const Optimizer = {
    start: async () => {
        const strat = document.getElementById('strategy-select').value;
        const data = App.data;
        if(!data.length) { alert("Veri yok!"); return; }

        document.getElementById('opt-progress-container').style.display = 'block';
        const bar = document.getElementById('opt-bar');
        const status = document.getElementById('opt-status-text');

        // Generate Variations
        let vars = [];
        if(strat === 'supertrend') {
            for(let p=7; p<=25; p+=2) for(let f=1; f<=6; f+=0.5) vars.push({st_period:p, st_factor:f});
        } else if(strat === 'turtle') {
            for(let e=10; e<=60; e+=5) for(let x=5; x<=30; x+=5) if(e>x) vars.push({tt_entry:e, tt_exit:x});
        } else if(strat === 'rsi') {
            for(let l=7; l<=21; l+=2) for(let ob=60; ob<=90; ob+=5) for(let os=10; os<=40; os+=5) vars.push({rsi_len:l, rsi_ob:ob, rsi_os:os});
        } else if(strat === 'macd') {
            vars.push({m_fast:12, m_slow:26, m_sig:9});
            vars.push({m_fast:8, m_slow:21, m_sig:5});
            vars.push({m_fast:5, m_slow:35, m_sig:5});
            for(let f=5; f<=15; f+=5) for(let s=20; s<=50; s+=10) vars.push({m_fast:f, m_slow:s, m_sig:9});
        } else if(strat === 'bollinger') {
            for(let l=10; l<=50; l+=5) for(let s=1.5; s<=3.5; s+=0.5) vars.push({bb_len:l, bb_std:s});
        }

        let bestPnL = -Infinity;
        let bestParams = null;
        const total = vars.length;

        // Async Loop
        for(let i=0; i<total; i++) {
            // UI Update (Non-blocking)
            if(i % 5 === 0) {
                bar.value = (i/total)*100;
                status.innerText = `Test ediliyor: ${i}/${total}`;
                await new Promise(r => setTimeout(r, 0)); 
            }

            const res = Backtest.run(data, strat, vars[i]);
            if(res.balance > bestPnL) {
                bestPnL = res.balance;
                bestParams = vars[i];
            }
        }

        // Apply Results
        if(bestParams) {
            for(let k in bestParams) document.getElementById(k).value = bestParams[k];
            status.innerText = "Optimizasyon Tamamlandı!";
            bar.value = 100;
            App.run(); // Re-run with best
            alert(`Maksimum Bakiye: $${bestPnL.toFixed(2)} bulundu.`);
        }
    }
};

// Start
window.addEventListener('DOMContentLoaded', App.init);
</script>
</body>
</html>